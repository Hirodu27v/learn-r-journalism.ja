静的な地図

このセクションでは、空間データ、シェープファイル、および国勢調査データをマッピングするための基礎的な方法について説明します。

空間データは、最初はとっつきにくいように見えます。
ジャーナリストがどのように空間データを使用するのかに進む前に、できる限り簡単に説明します。
できれば、詳細を後で自分で勉強しておいてください。

空間データは二つの重要な情報を含んでいます。

* オブジェクトの座標
* 座標が地球上の地点とどのように関連しているか
    * 座標参照系、**CRS**とも呼ばれます。
**CRS**には２種類あります。 

* 測地系
    * 地球の3次元モデルを使用して、グリッドの表面上の特定の位置を定義します。
    * 経度（東/西）および緯度（北/南）
* 投影座標系
    * 三次元グリッドを二次元平面に投影したものです。
    
![](/mapping/static_maps/images/projection_tween.gif)

選択可能な[地図投影法](https://xkcd.com/977/)はたくさんあります。おそらく最もなじみ深いのは、Googleマップで使われているメルカトル（WGS84）です。


### ラスタデータとベクターデータ

CRSを持つ空間データはベクターかラスターのいずれかです。

* ベクター
    * 点で結ばれた線やポリゴン（面）に基づき
    * 座標参照系内にあります。
    * 例: 道路図
* ラスター
    * グリッドシステム内の値
    * 例: 衛星画像


{{% notice note %}}
このクラスではベクタデータと **sf** パッケージを扱います。以前の **sp**パッケージではベクターとラスタの両方が使えました。
システムを準備するのに手間がかかります。 **sp** と **sf** の主な違いはCRS情報の格納方法です。
**sp** は空間サブクラスを使用しますが、 **sf** はデータをデータフレームに格納し、先に学習した**dplyr** を使えるようにします。 
興味がある方は、他の空間データ分析とモデリングについての [クラス](http://www.rspatial.org/) を調べてみてください。
{{% /notice %}}

## シェープファイル

Rは、KMLやgeojsonなど、多様なファイル形式の空間データをインポートすることができます。90年代にESRIが作成したシェープファイルに焦点を当てます。

シェープファイルは、単数のファイルのように呼ばれていますが、少なくとも三つの基本ファイルの集合体です。

* .shp - 図形の情報をリストする
* .shx - インデックス情報を保持する
* .dbf - 図形の属性（データ）ファイル

正しくインポートするには、すべてのファイルがディレクトリ内に存在し、同じ名前（ファイル拡張子を除く）でなければなりません。

## これからやること

空間データを扱う方法をいくつか見ていき、スタイルを少しずつ改良します。

1. ダウンロードした後、空白のシェープファイルをマッピングする
2. 国勢調査データを空白のシェープファイルに結合してマッピングする
3. Rの **Tigris** パッケージでシェープファイルをダウンロードする
4. **censusapi** パッケージで国勢調査データをダウンロードし、新しいシェープファイルに結合する
5. **tidycensus**を使って国勢調査データとシェープファイルを一括してダウンロードする

データを可視化するために **sf** パッケージを **ggplot2** と組み合わせて使いましょう。

{{% notice important %}}
**Macを使っているなら**、**sf**を使って地図を作成するとパフォーマンス上の問題が発生します。修正するには[XQuartz](https://www.xquartz.org/)をダウンロードし、再起動して次のコマンドを実行します。 options(device = "X11")、そして X11.options(type = "cairo")
{{% /notice %}}


### 単純なシェープファイルのマッピング

まず、 [国勢調査](https://www.census.gov/geo/maps-data/data/tiger-cart-boundary.html)から州の境界のシェープファイルを読み込むことから始めます。

```{r simple_states, warning=F, message=F}
# ggplot2とsfをインストールしていなければ、以下の行のコメントを外して実行してください。
#install.packages("ggplot2")
#install.packages("sf")

library(ggplot2)
library(sf)

# Macユーザーは、以下の行のコメントを外して実行してください。
#options(device = "X11") 
#X11.options(type = "cairo")

fifty_location <- "data/cb_2017_us_state_20m/cb_2017_us_state_20m.shp"
fifty_states <- st_read(fifty_location)
```

```{r view_fifty, eval=F}
View(fifty_states)
```

![](/mapping/static_maps/images/view1.png)



シェープファイルをインポートするために `st_read()` 関数を使いました。

```{r plot_fifty_simple, fig.width=9, fig.height=5}
ggplot(fifty_states) + geom_sf()
```

これでよし。ハワイとアラスカを含む各州の境界を設定できました。

**ggplot2** は一つの画像に全てを収めるようにしますが、これはシステムに負荷をかけます。 

塗りつぶすデータがないため、色はありません。

 [CensusReporter.org](https://censusreporter.org/data/table/?table=B02001&geo_ids=040|01000US)から人口データを取得しましょう。

```{r import_pop_csv, warning=F, message=F}
# readをインストールしていなければ、以下の行のコメントを外して実行してください。
#install.packages("readr")

library(readr)
populations <- read_csv("data/acs2016_1yr_B02001_04000US55.csv")

```

```{r viewpop, , eval=F}
View(populations)
```

![](/mapping/static_maps/images/view2.png)

### データを空白のシェープファイルに結合してマッピングする

シェープファイルと人口のデータセットがあります。両方ともデータフレームなので、結合は簡単です。州名は、データセットを結合する足がかりになります。各データフレームの列名は州名とは異なりますが、簡単に結合できます。

```{r join_data1, warning=F, message=F}
ncol(fifty_states)

library(dplyr)

fifty_states <- left_join(fifty_states, populations,
                          by=c("NAME"="name"))
```

```{r viewfifty}
ncol(fifty_states)
```

素晴らしい。**fifty_states** の変数は10から31に増えました。

このデータフレームには多くの変数があります。チェックしてみましょう。

```{r colnames_fifty}
colnames(fifty_states)
```

こんな感じでいいでしょう。

* **STATEFP** は州コードです。
    * 連邦情報処理標準を表します。州、郡、国勢調査区域などを識別する標準的な方法です。
* **GEOID** もFIPSコードの一部です。
    * ここでは、２桁の数字です。
    * 国勢調査の区分が詳細になるほど、数値は長くなります。
* **B02001001**, **B02001002**など
    * これは、国勢調査情報の表への参照です。
    * 例えば [**B02001001**](https://www.socialexplorer.com/data/ACS2016_5yr/metadata/?ds=ACS16_5yr&var=B02001001) はポリゴンデータ内の総人口です。
    * 国勢調査からデータをエクスポートすると、変数はこのような形式に変換されます。
    * ダウンロードや [調べる](https://www.census.gov/programs-surveys/acs/guidance/which-data-tool/table-ids-explained.html)必要があるときには覚えておく必要があります。
* **B02001001, Error**
    * これらはあくまで推定値なので、誤差のマージンが含まれています。
* **geometry** 
    *  CRS データです。
    
`geom_sf()` を使って、人口変数 **B02001001**をマッピングしましょう。そして、描画が遅くなるのを避けるためにハワイとアラスカを除外します。申し訳ない！でも必ず後で補います。


```{r joined_map, fig.width=9, fig.height=5}
forty_eight <- fifty_states %>% 
  filter(NAME!="Hawaii" & NAME!="Alaska" & NAME!="Puerto Rico")


ggplot(forty_eight) +
  geom_sf(aes(fill=B02001001)) +
  scale_fill_distiller(direction=1, name="Population") +
  labs(title="Population of 48 states", caption="Source: US Census")
```

実にベーシックでそう悪くありません。 x軸とy軸は緯度と経度です。

ここまで、シェープファイルとデータをローカルに取り込む方法、それらを結合する方法、そしてマッピングする方法について説明しました。

何を探索するか分かっているなら、シェープファイルをより効率的に扱う方法があります。

### シェープファイルを直接Rにダウンロードする

 [**tigris**](https://github.com/walkerke/tigris) パッケージを使用すると、 [国勢調査のシェープファイルを](https://www.census.gov/geo/maps-data/data/tiger-line.html) ファイルの解凍やディレクトリの指定をせずに直接Rに取り込むことができます。パッケージ作者のKyle Walkerによる[詳細な紹介](https://walkerke.github.io/tigris-webinar/) があります。

シェープファイルは、次のような関数を参照することで簡単にダウンロードできます。
* `tracts()`
* `counties()`
* `school_districts()`
* `roads()`

まず、シェープファイルが **sf** ファイルになっていることを確認しましょう ( **sp**バージョンもあるので)。


```{r tigris_install, warning=F, message=F, quietly=T, echo=T, results='hide'}
# tigris をインストールしていなければ、以下の行のコメントを外して実行してください。
#install.packages("tigris")

library(tigris)

# sf オプションの設定

options(tigris_class = "sf")

tx <- counties("TX", cb=T)

#If cb is set to TRUE, download a generalized (1:500k) counties file. Defaults to FALSE (the most detailed TIGER file).

# 地続きではない州を除外する (ごめんね!)

ggplot(tx) + 
  geom_sf() +
  theme_void() +
  theme(panel.grid.major = element_line(colour = 'transparent')) +
  labs(title="Texas counties")
```

よし。軸、グリッド、背景を削除するために2、3行新しいコードを加えました。

本物の地図のように見えます。後はデータを追加するだけです。



<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
  <iframe src="//www.youtube.com/embed/fyt7UqYEESs?t=3s" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0; encrypted-media" allowfullscreen title="YouTube Video"></iframe>
</div>



## Downloading Census data into R via API

Instead of downloading data from the horrible-to-navigate Census [FactFinder](https://factfinder.census.gov/faces/nav/jsf/pages/index.xhtml) or pleasant-to-navigate [CensusReporter.org](https://censusreporter.org/) we can pull the code with the [**censusapi** package](https://hrecht.github.io/censusapi/articles/getting-started.html) from Hannah Recht, of Bloomberg.

First, sign up for a [census key](https://api.census.gov/data/key_signup.html).

```{r census_key, eval=F}
# Add key to .Renviron
Sys.setenv(CENSUS_KEY="YOURKEYHERE")
# Reload .Renviron
readRenviron("~/.Renviron")
# Check to see that the expected key is output in your R console
Sys.getenv("CENSUS_KEY")
```

```{r loading_my_key, echo=F}
source("key.R")
Sys.setenv(CENSUS_KEY=census_key)
readRenviron("~/.Renviron")
```

```{r load_censusapi, warning=F, message=F}
# If you don't have censusapi installed yet, uncomment the line below and run
#install.packages("censusapi")

library(censusapi)
```

Check out the dozens of data sets you have access to now.

```{r vewapi, eval=F}
apis <- listCensusApis()
View(apis)
```

![](/mapping/static_maps/images/apis.png)

We won't get too deep into the usage of **censusapi**, though I recommend the [excellent documentation](https://hrecht.github.io/censusapi/articles/getting-started.html) later.

We'll focus on using the `getCensus()` function form the package. It makes an API call and returns a data frame of results.

These are the arguments you'll need to pass it:

* `name` - the name of the Census data set, like "acs5" or "timeseries/bds/firms"
* `vintage` - the year of the data set
* `vars` - one or more variables to access (remember *B02001001* from above?)
* `region` - the geography level of data, like county or tracts or state

You can use `listCensusMetadata()` to see what tables might be available from the ACS Census survey.


{{% notice warning %}}
The following lines of code using listCensusMetadata will take a very long time to load, so you can skip this step for now. Also, at the moment of this class this line of code won't work unless you have the developer version.
{{% /notice %}}


```{r metadata, warning=F, message=F, eval=F}
# The lines below will make sure you have the developer version
# of censusapi so listCensusMetaData() will work correctly

install.packages("devtools")
devtools::install_github("hrecht/censusapi")

acs_vars <- listCensusMetadata(name="acs/acs5", type="variables", vintage=2016)

View(acs_vars)
```
![](/mapping/static_maps/images/race.png)

It takes quite a few minutes to download the list of this data set (23,000 rows!) but once you get it, you can explore it to see what sort of data you might like to download. You can also refer to the Census for [some guidance](https://www.census.gov/programs-surveys/acs/guidance/which-data-tool/table-ids-explained.html).

We'll pull median income: *B21004_001E*

```{r median_income, warning=F, message=F}
tx_income <- getCensus(name = "acs/acs5", vintage = 2016, 
    vars = c("NAME", "B19013_001E", "B19013_001M"), 
    region = "county:*", regionin = "state:48")
head(tx_income)
```
 
Alright, time to join it to our **tx** spatial data frame and map it.

```{r, tx_income, warning=F, message=F}
# Can't join by NAME because tx_income data frame has "County, Texas" at the end
# We could gsub out the string but we'll join on where there's already a consistent variable, even though the names don't line up

tx4ever <- left_join(tx, tx_income, by=c("COUNTYFP"="county"))


ggplot(tx4ever) + 
  geom_sf(aes(fill=B19013_001E), color="white") +
  theme_void() +
  theme(panel.grid.major = element_line(colour = 'transparent')) +
  scale_fill_distiller(palette="Oranges", direction=1, name="Median income") +
  labs(title="2016 Median income in Texas counties", caption="Source: US Census/ACS5 2016")

```


### Download Census data and shapefiles together

The most recent package dealing with Census data is [**tidycensus**](https://walkerke.github.io/tidycensus/index.html) and it brings together what we've done above-- the data and the geography. It's also created by Kyle Walker.

You can use it to pull data only like with **censusapi** or you can use it to pull shape files only, like with **tigris**.

But with **tidycensus**, you can download the shape files with the data you want already attached. No joins necessary. 

I won't get into the particulars of looking up geography types and Census variables.

Let's get right into mapping. We'll calculate unemployment percents by Census tract in Jersey City. It'll involve wrangling some data. But querying the data with `get_acs()` will be easy and so will getting the shape file by simply passing it `geometry=T`.

```{r tidycensus, warning=F, message=F}
# if you don't have tidycensus installed yet, uncomment and run the line below

#install.packages("tidycensus")
library(tidycensus)

# Pass it the census key you set up before
```

```{r key, eval=F}
census_api_key("YOUR API KEY GOES HERE")
```

```{r loading_my_key2, echo=F}
census_api_key(census_key)
```

```{r racejobvars, warning=F, message=F, quietly=T, echo=T, results='hide'}
jobs <- c(labor_force = "B23025_005E", 
              unemployed = "B23025_002E")

jersey <- get_acs(geography="tract", year=2016, variables= jobs, county = "Hudson", state="NJ", geometry=T)

head(jersey)
```

Time for some math. Can you follow what's happening in the code based on what you've learned in previous chapters?

We can string the **dplyr** wrangling and **ggplot2** code together. Just watch and look out for the transition from `%>%` to `+`.

```{r unemployed_nj, warning=F, message=F}
library(tidyr)

jersey %>% 
  mutate(variable=case_when(
    variable=="B23025_005" ~ "Unemployed",
    variable=="B23025_002" ~ "Workforce")) %>%
  select(-moe) %>% 
  spread(variable, estimate) %>% 
  mutate(percent_unemployed=round(Unemployed/Workforce*100,2)) %>% 
ggplot(aes(fill=percent_unemployed)) + 
  geom_sf(color="white") +
  theme_void() +
  theme(panel.grid.major = element_line(colour = 'transparent')) +
  scale_fill_distiller(palette="Reds", direction=1, name="Estimate") +
  labs(title="Percent unemployed in Jersey City", caption="Source: US Census/ACS5 2016") +
  NULL
  
```

### Faceting maps

One more example.

We'll pull the population of non-Hispanic whites, non-Hispanic blacks, non-Hispanic Asians, and Hispanics by Census tract for the 2010 Census. The function is `get_decennial()` and we'll also add the `summary_var` argument to get multi-group denominators.
 
```{r facet, warning=F, message=F, quietly=T, echo=T, results='hide'}
racevars <- c(White = "P0050003", 
              Black = "P0050004", 
              Asian = "P0050006", 
              Hispanic = "P0040003")

harris <- get_decennial(geography = "tract", variables = racevars, 
                  state = "TX", county = "Harris County", geometry = TRUE,
                  summary_var = "P0010001") 

head(harris)
```

This is a very tidy data frame. 

And looks like we've have some grouping material.


```{r faceting, warning=F, message=F}
# If you dont have the viridis package installed yet, uncomment and run the line below
#install.packages("viridis")

library(viridis)

harris %>%
  mutate(pct = 100 * (value / summary_value)) %>%
  ggplot(aes(fill = pct, color = pct)) +
  facet_wrap(~variable) +
  geom_sf() +
  coord_sf(crs = 26915) + 
  scale_fill_viridis(direction=-1) +
  scale_color_viridis(direction=-1) +
  theme_void() +
  theme(panel.grid.major = element_line(colour = 'transparent')) +
  labs(title="Racial geography of Harris County, Texas", caption="Source: US Census 2010")
```

Well, we've gone over a lot of mapping techniques that do pretty much the same thing.

But now you've got a grasp of all the options.

Pick which one works best for your case.

### About Alaska and Hawaii

Oh yeah.

If you pass `shift_geo=T` to the `get_acs()` function in **tidycensus** then the states will be re positioned.

```{r alaska_hawii, warning=F, message=F, quietly=T, echo=T, results='hide'}
county_pov <- get_acs(geography = "county",
                      variables = "B17001_002",
                      summary_var = "B17001_001",
                      geometry = TRUE,
                      shift_geo = TRUE) %>% 
  mutate(pctpov = 100 * (estimate/summary_est))

ggplot(county_pov) +
  geom_sf(aes(fill = pctpov), color=NA) +
  coord_sf(datum=NA) +
  labs(title = "Percent of population in poverty by county",
       subtitle = "Alaska and Hawaii are shifted and not to scale",
       caption = "Source: ACS 5-year, 2016",
       fill = "% in poverty") +
  scale_fill_viridis(direction=-1)

```

So, why not use **tidycensus** every time instead of **tigris**? 

Well, you don't need a Census key API to use **tigris**.

