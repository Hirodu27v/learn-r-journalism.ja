##ggplot2でチャートを作る

データをロードしてチャートを作成し、レイヤーを細分化しましょう。

[Vulture.com](http://www.vulture.com/2013/04/leading-men-age-but-their-love-interests-dont.html) から、映画の主演男優と恋の相手の年齢を比較したデータをいくつか紹介します。


```{r importing_data, warning=F, message=F}
library(readr)

ages <- read_csv("data/ages.csv")

head(ages)
```
これが私たちが扱うデータです。

変数/列は、映画の題名、ジャンル、俳優、俳優の年齢、女優、女優の年齢、予算です。

これがチャートです。コンソールで実行してください。

```{r chart_example, warning=F, message=F}
# まだggplot2パッケージをインストールしていなければ、以下の行のコメントを外して実行してください。
#install.packages("ggplot2")

library(ggplot2)

ggplot(data=ages) +
   geom_point(mapping=aes(x=actor_age, y=actress_age)) +
   expand_limits(x = 0, y = 0) +
   geom_abline(intercept=0, col="light gray")

```

このチャートは何を示しているのでしょうか？映画では、男性は女性よりもはるかに年上の設定です。

このチャートの構成要素を分解しましょう。

![](/visualizing/charts_with_ggplot/images/gg1.png)

まずは　**データフレーム**　からです。 **年齢**　を`ggplot()`に渡して初期化しました。


![](/visualizing/charts_with_ggplot/images/gg1c.png)

![](/visualizing/charts_with_ggplot/images/gg2.png)

次に、視覚化するために選択したデータがドットでx軸とy軸に表示されます。

マッピングは、aestheticsがデータ内の変数とどのように関連するかを記述します。

![](/visualizing/charts_with_ggplot/images/gg2c.png)

データを視覚的特性として表す　**aesthetics** (`aes()`) を設定します。

デフォルトの幾何学的オブジェクトと色を使用していますが、これらはカスタマイズ可能です。

* ポジション
* サイズ
* 色
* 形状
* 透明度
* 塗りつぶし

それぞれの **aesthetic**　に対して、 視覚的特性をどのように表示値に変換するか **scales** を設定できます。後でやってみましょう。

`ggplot()`に追加した `geom_`関数を見てみましょう。

![](/visualizing/charts_with_ggplot/images/gg2d.png)

**ggplot2** では関数の間にプラスを忘れずに。

`%>%` パイピングを実装した **dplyr** の前に作成されました。

パイピングのショートカットは私には条件反射的なので、とても混乱しがちです。

ggplotを使っているのであれば、プラス！

そうでなければ、パイプ！


![](/visualizing/charts_with_ggplot/images/gg2e.png)

So `geom_point()` は `geom_bar()` や `geom_boxplot()`のように *geom_functions*　のうちの１種類です。

*geom_function* に関わらず *mappings* に渡す必要があります。

このチャートのインスタンスでは、**ages**　の **actor_age** と **actress_age** に当たります。

これがRで`ggplot()` とデータ、`geom_`と`aes()`を使って.チャートを作成する基本です。この例にある他の2行を実行する必要はありません。

さらにわかりやすくするために説明を追加しました。

![](/visualizing/charts_with_ggplot/images/gg3.png)

![](/visualizing/charts_with_ggplot/images/gg3.png)

次の行は拡大・縮小のオプションです。

スケーリングは *geom_function*　の`aes()`に渡してもできますが、チャート全体にも適用できます。


![](/visualizing/charts_with_ggplot/images/gg3c.png)
このチャートでは、 `expand_limits()` 関数でX軸とY軸を０からスタートするように表示できます。

そうしない場合、 `ggplot()`はチャート内の点がチャート全体を埋めるようにスケールをシフトします。データが含まれていない余計な余白が求められていないと仮定するのです。

しかし、このデータは０から始めることで年齢の格差を強調します。 さらに、（いくつかの例外があるものの）ベースをゼロから開始しないことで見落とすかもしれないデータ視覚化の上での長所がたくさんあります。


![](/visualizing/charts_with_ggplot/images/gg4.png)

これまでに見てきたたくさんの関数の最後を飾るのは `ab_line()`です。 必須ではありませんが、 **ggplot2**　の階層化オプションの一部です。

![](/visualizing/charts_with_ggplot/images/gg4c.png)

 **ggplot2** の `geom_abline()` のような関数は追加の変数を渡すことができます。 この例では、切片を1、バーの色を「ライトグレー」に指定します。  `geom_abline()` に変数を渡さず、行はデフォルト幅にしましょう。


![](/visualizing/charts_with_ggplot/images/gg5.png)

それでは、他にもチャートを作ってみましょう。

しかしまずは、データについて考えてみましょう。

## データ

 `ggplot2()`の使用に際し、手元のデータの構造を理解することはとても重要です。

```{r head}

head(ages)

```

このデータフレームには六つの変数（列）があります。

各行は単一の映画のデータを表しており、整えられています。

きちんとしたフォーマットがあるように見えますが、すべてのデータセットがデフォルトでこの構造を持つわけではありません。

横持ちのデータと縦持ちのデータを扱った前の章を思い出してください。

![](/visualizing/charts_with_ggplot/images/wide.png)

各人種の変数は列に分散されています。

スプレッドシートの見栄えがよくなるだけで、 **ggplot2** ではうまくいきません。

![](/visualizing/charts_with_ggplot/images/long.png)

これでよし。各行には異なる変数が入っています。このようにして、メトロと人種あたりの解決率、事件数の合計に別の変数を追加できます。

より多機能です。

 `ggplot()`では、データは整えられ、縦持ちのフォーマットが最もうまくいくのです。

## Geom
新しい `geom_` タイプを見てみましょう。

### シンプルな棒グラフ


`geom_bar()`から始めましょう。これは、チャートの最も一般的なタイプです。
今回は`ggplot()`に `aes()`をネストしており、`method=` や`data=`を必要がないので使っていないことに注意してください。


```{r bar, fig.width=9, fig.height=5}
ggplot(ages,
    aes(x=actor)) +
    geom_bar()
```

それぞれのチャートで使用している変数の数を見てみましょう。
上の例では **一つの変数** から始め、データフレームに表示されるインスタンスを数えることによって新しい変数を作成しました。
チャートを機能させるために、データフレーム自体を変更したり要約したりする必要はありませんでした。
一般的な `geom_bar()` オプションは以下の通りです。

* 幅
* 塗りつぶし
* 色 (境界線)
* position_dodge()

### 積み上げ棒グラフ

```{r stacked_bar, fig.width=9, fig.height=5}
ggplot(data=ages,
  aes(x=actor, fill=Genre)) +
  geom_bar()
```

## 美学
他の種類のチャートに移る前に、上のチャートで起こったことについて話しましょう。
棒グラフと積み上げ棒グラフの唯一の違いは、`aes()` 関数に `, fill=Genre` が付け加えられたことです。

**変数の数:** 2 (すなわち俳優とジャンルです)

チャートの以下の外見は変更可能でしたね。
    
* ポジション
* サイズ
* 色
* 形状 
* 透明度
* 塗りつぶし

![](/visualizing/charts_with_ggplot/images/aes.png)

 `fill` を `color`に変更してみたらどうなるでしょうか?


```{r stacked_bar_color, fig.width=9, fig.height=5}
ggplot(data=ages,
  aes(x=actor, color=Genre)) +
  geom_bar()
```

それほど効果的ではないようです。でもまあ、オプションについて知ることができました。

どんな時に使うのがいいのでしょうか? 折れ線グラフかドットプロットがよいでしょう。

色と凡例が自動的に追加されたことに注意してください。


![](/visualizing/charts_with_ggplot/images/autocolor.png)
This is the default color list. There are ways to customize the colors, but we'll go over that in the next section.

Let's go back to `fill=Genre` but this time with a twist.

Take a look at the code and see if you can spot why it didn't work like it did earlier.

```{r stacked_bar_fill_fail, fig.width=9, fig.height=5}
ggplot(data=ages,
  aes(x=actor), fill=Genre) +
  geom_bar()
```

分かりますか?

It's the parenthesis in `aes()` -- it closed off before including `fill=Genre` so it wasn't included. Try it this time correctly.

```{r stacked_bar_fill_fail2, fig.width=9, fig.height=5}
ggplot(data=ages,
  aes(x=actor, fill=Genre)) +
  geom_bar()
```

### Grouped bar plot

```{r grouped_bar_plot, fig.width=9, fig.height=5}
ggplot(data=ages,
  aes(x=actor, fill=Genre)) +
  geom_bar(position="dodge")
```

So this chart was similar to the stacked bar plot above, but this time `position="dodge"` was passed to the `geom_bar()` function.

This tells ggplot to group the bar plot.

This is useful for easier comparison within groups.

### Spinogram

It's simple to turn a stacked bar plot into a percent-based chart.

```{r spinogram, fig.width=9, fig.height=5}
ggplot(data=ages,
  aes(x=actor, fill=Genre)) +
  geom_bar(position="fill")
```

This type of chart allows for a greater understanding of the proportion compared to other groups.


<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
  <iframe src="//www.youtube.com/embed/x4OMSY2kz8M?t=3s" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0; encrypted-media" allowfullscreen title="YouTube Video"></iframe>
</div>


### Box plot

You'll see this type of chart often in research papers.

It succinctly summarizes the distribution of numbers in each category we've set: actors.


```{r box_whiskers}
ggplot(ages, aes(x=actor, y=actress_age)) +
  geom_boxplot()
```

The height of the line is the max and min of the numbers in the y axis: actress ages.

The top of the box is the top quartile and the bottom of the box is the bottom quartile. The line in the middle is the median age. That floating dot? Considered an outlier.

Common `geom_boxplot()` options:

* fill
* color
* notch (=TRUE or FALSE)
* outlier. color shape size

### Violin plot

This is another way to show distribution of numbers.

```{r violin, fig.width=9, fig.height=5}
ggplot(ages, aes(x=actor, y=actress_age)) +
  geom_violin()
```

The wider the diameter, the more numbers there are. It's a bit more intuitive to follow.

**Variable count:** 2 - *actress_age* and *actor*

## Scaling

Useful to transform or rescale the data with.

## geom_histogram

```{r scaling1, warning=F, message=F}
ggplot(data=ages, aes(x=actor_age)) +
  geom_histogram(binwidth=1)
```

Common `geom_histogram()` options:

* binwidth
* color (border)
* fill

**Applying a logorithmic scale**

It makes more sense to apply scalar transformations to while plotting rather than altering the data set itself.

```{r scaling2}
ggplot(data=ages, aes(x=actor_age)) +
  geom_histogram() + scale_x_log10()
```

### Kernel density plot

```{r kernel, fig.width=9, fig.height=5}
ggplot(data=ages,
  aes(x=actress_age)) +
  geom_density(fill="red")
```
Common `geom_density()` options:

* fill
* color
* alpha

```{r kernel2, fig.width=9, fig.height=5}
ggplot(data=ages,
  aes(x=actress_age, fill=actor)) +
  geom_density(alpha=.3)
```

## Dot plot

```{r dotplot, fig.width=8, fig.height=8}
ggplot(ages,
       aes(x=actress_age, y=Movie)) +
  geom_point()
```

### Line plot

Let's start by summarizing the ages of the actresses per actor.

```{r lineplot, fig.width=9, fig.height=5, warning=F, message=F}
library(dplyr)

avg_age <- ages %>% 
  group_by(actor) %>%
  mutate(age_diff = actor_age-actress_age) %>% 
  summarize(average_age_diff = mean(age_diff))

ggplot(avg_age, aes(x=actor, y=average_age_diff, group=1)) +
  geom_line()
```

**Variable count:** 2 - the new mutated variable *average_age_diff* and **actor**

Don't forget, we can add more layers.

Let's make the same chart above but with dots, too.

```{r dot_line, fig.width=9, fig.height=5}
ggplot(avg_age, aes(x=actor, y=average_age_diff, group=1)) +
  geom_line() +
  geom_point()
```

Does this make sense as a visualization? Mmm... nah.

Never use a line chart to chart anything across an axis that doesn’t represent something continuous.

Common `geom_point()` options:

* color
* fill
* alpha
* shape
* size

### Scatterplot with fit

We've made a scatter plot before.

This time, let's add a `geom_smooth()` layer.

```{r scatter_fit}
ggplot(ages,
      aes(x=actor_age,
          y=actress_age)) +
  geom_point() +
  geom_smooth()
```

We can customize it and throw in a linear regression line. Notice the `~` which is used often in statistical analysis formulas.

```{r scatter_fit_lm}
ggplot(ages,
      aes(x=actor_age,
          y=actress_age)) +
  geom_point() +
  geom_smooth(method="lm",
              formula=y~x)
```

## Grouping

```{r grouping1}
ggplot(data=ages,
       aes(x=actor_age,
           y=actress_age,
           color=actor)) +
  geom_point()
```

**Variable count:** 3! We're working with *actor_age*, *actress_age*, and *actor*.

See how we're able to start packing more information into a chart with a line of code?

When you're exploring data visually, this might help surface insights you wouldn't notice by just looking at the raw data.

Everything's still pretty clustered in this chart so you might only be able to notice outliers like Tom Cruise and Johnny Depp on the bottom left. But everything in the middle is kinda just too much.

Let's go crazy and add another variable.


```{r grouping2}
ggplot(data=ages,
       aes(x=actor_age,
           y=actress_age,
           color=actor,
           shape=Genre)) +
  geom_point()
```

**Variable count:** 4! We're working with *actor_age*, *actress_age*, *actor*, and now *Genre*.

This looks not good.

Why did we do this?? I just wanted to show you that the shapes option exist. You'll probably never use it.

Okay, what if we try keeping the color and shapes to one variable: *actor*?

```{r grouping3}
ggplot(data=ages,
       aes(x=actor_age,
           y=actress_age,
           color=actor,
           shape=actor)) +
  geom_point()
```

Nope, still not great. Plus, there are only a limited amount of shapes to pull from.

Did you see that warning?

```
## Warning: Removed 10 rows containing missing values (geom_point).
```

That's because it couldn't find a shape for Tom Hanks. Hanks was left off the chart.

Don't you feel horrible? Tom Hanks is the nicest guy ever.

Like colors, you should limit the palette so it doesn't confuse readers. 


### Scatterplot with color and size

Let's swap out *Genre* for another variable that might make more sense to add to the visualization: *budget*.

```{r grouping4}
ggplot(data=ages,
       aes(x=actor_age,
           y=actress_age,
           color=actor,
           size=budget)) +
  geom_point()
```

**Variable count:** 4! We're working with *actor_age*, *actress_age*, *actor*, and now *Genre*.

Lots of data being communicated to readers here. The legends were auto-generated.

## Coords

You'll see **stats** in the `geom_bar()` function. This is the statistical transformations that summarize data. In this instance we're setting it to `"identity"` because we want the bars to represent the numbers in the `y` in `aes()`, not the count of it.

* counts
* means
* trend lines

We're going to alter the coordinates of the chart so that we get a horizontal chart instead of the default vertical one.

The `coord_flip()` option flips a chart you've been working on from vertical to horizontal or horizontal to vertical. 
    
```{r coords}
ggplot(data = avg_age, aes(x= actor, y=average_age_diff)) +
    geom_bar(stat="identity") +
    coord_flip()
```


<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
  <iframe src="//www.youtube.com/embed/xjnj-rJwd6A?t=3s" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0; encrypted-media" allowfullscreen title="YouTube Video"></iframe>
</div>


## Facets

Remember how that big scatter plot above had all the different colors on one viz and it was all clustered together?

It's simple to break those out into individual charts.

This is sometimes referred to as "small multiples".



```{r facet_grid, fig.width=9, fig.height=7}
ggplot(data=ages) +
   geom_point(mapping=aes(x=actor_age, y=actress_age)) + 
   expand_limits(x = 0, y = 0) +
   geom_abline(intercept=0, col="light gray") +
   facet_grid(Genre~actor)
```


**Variable count:** 4! - We're working with *actor_age*, *actress_age*, *actor*, and also *Genre*.

{{% notice note %}}
Take a moment to appreciate how easy this was. This is a pain in the ass in other languages, like D3. 
{{% /notice %}}


Want to add another variable? Let's do it. Add `size=budget` the `geom_point()`.

```{r facet_grid_more, fig.width=9, fig.height=7}
ggplot(data=ages) +
   geom_point(mapping=aes(x=actor_age, y=actress_age, size=budget)) + 
   expand_limits(x = 0, y = 0) +
   geom_abline(intercept=0, col="light gray") +
   facet_grid(Genre~actor)
```

**Variable count:** 5! - We're working with *actor_age*, *actress_age*, *actor*, and also *Genre* AND *budget*. The sizing kinda jumbles up the circles in some, but keep playing around with alpha or change the size of the chart, maybe. You can see it's quite easy to play around with the options until you find the right balance.

This is all possible thanks to the tidiness of the data structure.

The variables might contain more than one group but it's all tied back to rows with each individual movie.

Here are other types of ways to create "small multiples" through facets.

* `facets_grid(genre~actor)`
* `facets_grid(. ~ actor)` - just columns
* `facets_grid(actor ~ .)` - just rows
* `facets_wrap(~ var, ncol=#)` - one classification variable wrapped to fill page


```{r facet_grid2}
ggplot(data=ages) +
   geom_point(mapping=aes(x=actor_age, y=actress_age)) + 
   expand_limits(x = 0, y = 0) +
   geom_abline(intercept=0, col="light gray") +
   facet_grid(.~actor)
```

You don't have to use two variables in `facet_grid()` -- you can just use one and it'll break out the charts based on where the `~` is in relation to the variable and the `.`.

The chart above had `facet_wrap(.~actor)` so the grid is split vertically.

If it was swapped to `facet_wrap(actor~.)` then the grid will split by row.


```{r facet_grid3}
ggplot(data=ages) +
   geom_point(mapping=aes(x=actor_age, y=actress_age)) + 
   expand_limits(x = 0, y = 0) +
   geom_abline(intercept=0, col="light gray") +
   facet_grid(actor~.)
```


I find myself using `facet_wrap()` more often because I can customize the number of columns in the small multiples with `ncol=`.


```{r facet_wrap, fig.width=9, fig.height=6}
ggplot(data=ages) +
   geom_point(mapping=aes(x=actor_age, y=actress_age)) + 
   expand_limits(x = 0, y = 0) +
   geom_abline(intercept=0, col="light gray") +
   facet_wrap(~actor, ncol=4)
```

## Global versus Local

The layers in your `ggplot()` chart can be customized in nuanced ways.

Everything nested in the initial `ggplot()` call will be considered global and apply to the rest of the layers.


```{r global, fig.width=9, fig.height=6}
ggplot(ages,
      aes(x=actor_age,
          y=actress_age)) +
      geom_point()
```


So in the chart above, `aes()` with *actor_age* and *actress_age* are in the x and y globally.

But I can also pass `aes()` to the `geom_point()` layer, which will make that local and apply to that layer only.

```{r local, fig.width=9, fig.height=6}
ggplot(ages,
      aes(x=actor_age,
          y=actress_age)) +
      geom_point(aes(color=actor))
```

You can also set data locally. 

This is very useful if you want to highlight a specific subset from the data.

```{r local2, fig.width=9, fig.height=6}
# Let's make a copy of the  minus the actor variable so it can't be faceted

ages_copy <- ages %>% select(-actor)

ggplot(data=ages,
      aes(x=actor_age,
          y=actress_age,
          color=actor)) +
      geom_point(data=ages_copy, color="grey") +
      geom_point() +
      facet_wrap(~actor) +
      theme(legend.position="none") # This removes the legend
```


We were able to use different data sets. Globally, we wanted to use the **ages** data frame because we were going to facet it.

We needed a second data set without the *actor* variable to plot in a background layer and set the color manually to "grey" (go back to the code above and this time put `color="grey"` in `aes()` and see the difference). This was the first `geom_point()` layer referenced locally.

The second `geom_point()` built a scatter plot based on the global data set in `ggplot()`.

This type of chart really improves on that first grouped scatter plot because it makes it easier to see each individual group in the context to the rest of the data.


----

## Your turn

Challenge yourself with [these exercises](http://code.r-journalism.com/chapter-4/#section-ggplot2) so you'll retain the knowledge of this section.

Instructions on how to run the exercise app are on the [intro page](https://learn.r-journalism.com/en/visualizing/) to this section.


---

## Next steps

With some practice and understanding of [basic geom-types](https://ggplot2.tidyverse.org/reference/#section-layer-geoms) you can quickly iterate through different ways to visualize your data.

Once your data is structured correctly, you can use **ggplot2** to slice, group, and facet data visually multiple ways until you find something worth elaborating on.

What is being communicated? What information is left out or obscured?

Going through these examples, you saw how shapes, layout, the number of variables, etc, all matter. Swapping out geoms and aesthetics. Different combinations communicated better than others. It all depends on the structure of the data and what it contains.

By visualizing data with the grammar of graphics, you'll approach data in a flexible new way.

Great, now let's do more with charts including how to move beyond exploring the data visually and how to turn get these charts to publication quality.

